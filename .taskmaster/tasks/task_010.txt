# Task ID: 10
# Title: Implement System Integration and Auto-Updates
# Status: pending
# Dependencies: 7, 8
# Priority: low
# Description: Integrate MCP Control Lite with macOS system features and implement an auto-update mechanism to keep the application current.
# Details:
Implement system integration features:

1. Menu Bar Integration:
```typescript
// In Tauri main.rs
fn main() {
  tauri::Builder::default()
    .setup(|app| {
      let window = app.get_window("main").unwrap();
      
      // Create system tray menu
      let tray_menu = tauri::SystemTrayMenu::new()
        .add_item(tauri::CustomMenuItem::new("show".to_string(), "Show MCP Control"))
        .add_item(tauri::CustomMenuItem::new("servers".to_string(), "Manage Servers"))
        .add_separator()
        .add_item(tauri::CustomMenuItem::new("quit".to_string(), "Quit"));
      
      // Create system tray
      let system_tray = tauri::SystemTray::new()
        .with_menu(tray_menu)
        .with_tooltip("MCP Control Lite");
      
      // Add system tray to app
      app.system_tray(system_tray);
      
      // Handle system tray events
      app.on_system_tray_event(move |app, event| match event {
        tauri::SystemTrayEvent::MenuItemClick { id, .. } => match id.as_str() {
          "show" => {
            window.show().unwrap();
            window.set_focus().unwrap();
          }
          "servers" => {
            window.show().unwrap();
            window.set_focus().unwrap();
            window.emit("navigate", "servers").unwrap();
          }
          "quit" => {
            app.exit(0);
          }
          _ => {}
        },
        tauri::SystemTrayEvent::LeftClick { .. } => {
          window.show().unwrap();
          window.set_focus().unwrap();
        }
        _ => {}
      });
      
      Ok(())
    })
    .run(tauri::generate_context!("tauri.conf.json"))
    .expect("error while running tauri application");
}
```

2. Auto-Launch at Login:
```typescript
// In settings.ts
async function setAutoLaunch(enable: boolean): Promise<void> {
  if (enable) {
    await invoke('enable_auto_launch');
  } else {
    await invoke('disable_auto_launch');
  }
}

// In Tauri main.rs
#[tauri::command]
fn enable_auto_launch() -> Result<(), String> {
  let app_name = "MCP Control Lite";
  let app_path = std::env::current_exe().map_err(|e| e.to_string())?;
  
  // Use macOS-specific API to add login item
  #[cfg(target_os = "macos")]
  {
    use cocoa::base::nil;
    use cocoa::foundation::{NSArray, NSString};
    use objc::{msg_send, sel, sel_impl};
    
    unsafe {
      let shared_file_list = msg_send![class!(LSSharedFileList), sharedFileListWithType:kLSSharedFileListSessionLoginItems];
      let app_url = msg_send![class!(NSURL), fileURLWithPath:NSString::alloc(nil).init_str(&app_path.to_string_lossy())];
      let login_items = msg_send![shared_file_list, copySnapshot];
      let login_items_array: NSArray = msg_send![login_items, allObjects];
      
      // Check if already in login items
      let count: usize = msg_send![login_items_array, count];
      let mut exists = false;
      
      for i in 0..count {
        let item = msg_send![login_items_array, objectAtIndex:i];
        let url: *mut Object = msg_send![item, URL];
        let path: *mut Object = msg_send![url, path];
        let existing_path: &str = msg_send![path, UTF8String];
        
        if existing_path == app_path.to_string_lossy() {
          exists = true;
          break;
        }
      }
      
      if !exists {
        let _: () = msg_send![shared_file_list, addURL:app_url withName:NSString::alloc(nil).init_str(app_name)];
      }
    }
  }
  
  Ok(())
}

#[tauri::command]
fn disable_auto_launch() -> Result<(), String> {
  // Similar implementation to remove from login items
  Ok(())
}
```

3. Auto-Update System:
```json
// In tauri.conf.json
{
  "tauri": {
    "updater": {
      "active": true,
      "endpoints": [
        "https://releases.mcp-control-lite.example.com/{{target}}/{{current_version}}"
      ],
      "dialog": true,
      "pubkey": "YOUR_UPDATER_PUBLIC_KEY"
    }
  }
}
```

```typescript
// In App.tsx or main component
import { checkUpdate, installUpdate } from '@tauri-apps/api/updater';
import { relaunch } from '@tauri-apps/api/process';

function App() {
  useEffect(() => {
    checkForUpdates();
  }, []);
  
  async function checkForUpdates() {
    try {
      const { shouldUpdate, manifest } = await checkUpdate();
      
      if (shouldUpdate) {
        // Show update dialog
        if (confirm(`Update ${manifest.version} is available. Install now?`)) {
          // Install the update
          await installUpdate();
          // Relaunch the app
          await relaunch();
        }
      }
    } catch (error) {
      console.error('Failed to check for updates:', error);
    }
  }
  
  // Rest of component
}
```

4. Notifications:
```typescript
// In notifications.ts
import { isPermissionGranted, requestPermission, sendNotification } from '@tauri-apps/api/notification';

async function sendServerStatusNotification(serverName: string, status: string): Promise<void> {
  let permissionGranted = await isPermissionGranted();
  
  if (!permissionGranted) {
    const permission = await requestPermission();
    permissionGranted = permission === 'granted';
  }
  
  if (permissionGranted) {
    sendNotification({
      title: 'MCP Server Status',
      body: `${serverName} is now ${status}`,
      icon: status === 'running' ? 'server-running.png' : 'server-stopped.png'
    });
  }
}
```

5. Logging System:
```typescript
// In logger.ts
class Logger {
  private logPath: string;
  private maxLogSize: number = 10 * 1024 * 1024; // 10 MB
  private maxLogFiles: number = 5;
  
  constructor(logPath?: string) {
    this.logPath = logPath || path.join(os.homedir(), 'Library', 'Logs', 'MCP Control Lite');
    this.initializeLogDirectory();
  }
  
  private async initializeLogDirectory(): Promise<void> {
    await fs.mkdir(this.logPath, { recursive: true });
    await this.rotateLogsIfNeeded();
  }
  
  private async rotateLogsIfNeeded(): Promise<void> {
    const currentLogPath = path.join(this.logPath, 'mcp-control.log');
    
    try {
      const stats = await fs.stat(currentLogPath);
      
      if (stats.size >= this.maxLogSize) {
        // Rotate logs
        for (let i = this.maxLogFiles - 1; i > 0; i--) {
          const oldPath = path.join(this.logPath, `mcp-control.log.${i}`);
          const newPath = path.join(this.logPath, `mcp-control.log.${i + 1}`);
          
          try {
            await fs.access(oldPath);
            await fs.rename(oldPath, newPath);
          } catch (error) {
            // File doesn't exist, ignore
          }
        }
        
        // Rename current log to .1
        await fs.rename(currentLogPath, path.join(this.logPath, 'mcp-control.log.1'));
      }
    } catch (error) {
      // Log file doesn't exist yet, ignore
    }
  }
  
  async log(level: 'info' | 'warn' | 'error', message: string, data?: any): Promise<void> {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      data
    };
    
    const logLine = JSON.stringify(logEntry) + '\n';
    
    await this.rotateLogsIfNeeded();
    await fs.appendFile(path.join(this.logPath, 'mcp-control.log'), logLine);
  }
  
  async info(message: string, data?: any): Promise<void> {
    await this.log('info', message, data);
  }
  
  async warn(message: string, data?: any): Promise<void> {
    await this.log('warn', message, data);
  }
  
  async error(message: string, data?: any): Promise<void> {
    await this.log('error', message, data);
  }
  
  async getRecentLogs(lines: number = 100): Promise<any[]> {
    try {
      const logContent = await fs.readFile(path.join(this.logPath, 'mcp-control.log'), 'utf-8');
      const logLines = logContent.split('\n').filter(Boolean);
      const recentLines = logLines.slice(-lines);
      
      return recentLines.map(line => JSON.parse(line));
    } catch (error) {
      return [];
    }
  }
}
```

Implement code signing for macOS distribution:

```bash
# Code signing script
#!/bin/bash

# Set variables
APP_PATH="./target/release/bundle/macos/MCP Control Lite.app"
IDENTITY="Developer ID Application: Your Name (XXXXXXXXXX)"

# Sign the application
codesign --force --options runtime --sign "$IDENTITY" "$APP_PATH"

# Verify signature
codesign --verify --deep --strict "$APP_PATH"

# Create DMG for distribution
create-dmg \
  --volname "MCP Control Lite" \
  --background "./assets/dmg-background.png" \
  --window-pos 200 120 \
  --window-size 800 400 \
  --icon-size 100 \
  --icon "MCP Control Lite.app" 200 190 \
  --hide-extension "MCP Control Lite.app" \
  --app-drop-link 600 185 \
  "MCP Control Lite.dmg" \
  "$APP_PATH"

# Sign the DMG
codesign --force --sign "$IDENTITY" "MCP Control Lite.dmg"
```

# Test Strategy:
1. Test menu bar integration on macOS
2. Test auto-launch functionality
3. Test auto-update mechanism with mock update server
4. Test notification system
5. Test logging system and log rotation
6. Test code signing and notarization process
7. Test application behavior after updates
8. Test system integration on different macOS versions
9. Test memory usage and performance over time
10. Test application behavior when system resources are constrained
