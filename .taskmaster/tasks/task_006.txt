# Task ID: 6
# Title: Implement MCP Server Management
# Status: done
# Dependencies: 1, 4
# Priority: medium
# Description: Build functionality to discover, install, update, and monitor MCP servers on the system.
# Details:
Create a ServerManager class to handle MCP server lifecycle management:

```typescript
class ServerManager {
  private serverRegistry: ServerRegistry;
  private configEngine: ConfigurationEngine;
  private runningServers: Map<string, any> = new Map(); // Server ID to process info
  
  constructor(configEngine: ConfigurationEngine) {
    this.configEngine = configEngine;
    this.serverRegistry = {
      availableServers: [],
      installedServers: [],
      lastScan: null
    };
  }
  
  // Scan for available MCP servers
  async discoverServers(): Promise<void> {
    // Scan standard locations for MCP servers
    const builtInServers = await this.scanBuiltInServers();
    const thirdPartyServers = await this.scanThirdPartyServers();
    const customServers = await this.scanCustomServers();
    
    this.serverRegistry.availableServers = [
      ...builtInServers,
      ...thirdPartyServers,
      ...customServers
    ];
    
    this.serverRegistry.lastScan = new Date();
  }
  
  // Scan for built-in servers
  private async scanBuiltInServers(): Promise<MCPServerConfig[]> {
    // Implementation for scanning built-in servers
    // These might be filesystem, git, etc.
    return [];
  }
  
  // Scan for third-party servers
  private async scanThirdPartyServers(): Promise<MCPServerConfig[]> {
    // Implementation for scanning third-party servers
    return [];
  }
  
  // Scan for custom user servers
  private async scanCustomServers(): Promise<MCPServerConfig[]> {
    // Implementation for scanning custom servers
    return [];
  }
  
  // Install a new MCP server
  async installServer(serverConfig: MCPServerConfig): Promise<void> {
    // Implementation for server installation
    // This might involve downloading, unpacking, and configuring
    
    // Add to installed servers
    this.serverRegistry.installedServers.push(serverConfig);
    
    // Add to configuration engine
    await this.configEngine.updateServerConfiguration(serverConfig);
  }
  
  // Update an existing MCP server
  async updateServer(serverId: string, newVersion: string): Promise<void> {
    // Implementation for server update
  }
  
  // Remove an MCP server
  async removeServer(serverId: string): Promise<void> {
    // Implementation for server removal
  }
  
  // Start an MCP server
  async startServer(serverId: string): Promise<void> {
    const serverConfig = this.configEngine.getServerConfiguration(serverId);
    if (!serverConfig) {
      throw new Error(`Server not found: ${serverId}`);
    }
    
    // Check if already running
    if (this.runningServers.has(serverId)) {
      return; // Already running
    }
    
    // Implementation for starting server process
    // This would spawn a child process or use other means to start the server
    
    // Track running server
    // this.runningServers.set(serverId, process);
  }
  
  // Stop an MCP server
  async stopServer(serverId: string): Promise<void> {
    // Implementation for stopping server
  }
  
  // Get server status
  getServerStatus(serverId: string): 'running' | 'stopped' | 'error' | 'unknown' {
    // Implementation for getting server status
    return 'unknown';
  }
  
  // Get all server statuses
  getAllServerStatuses(): Record<string, 'running' | 'stopped' | 'error' | 'unknown'> {
    const statuses: Record<string, 'running' | 'stopped' | 'error' | 'unknown'> = {};
    
    for (const server of this.serverRegistry.installedServers) {
      statuses[server.id] = this.getServerStatus(server.id);
    }
    
    return statuses;
  }
}
```

Implement process management for starting, stopping, and monitoring MCP servers. This may involve spawning child processes, communicating with them, and monitoring their health. Consider using Node.js child_process module or a more robust process management library.

# Test Strategy:
1. Unit tests for server discovery functionality
2. Tests for server installation, update, and removal
3. Tests for server process management (start/stop)
4. Tests for server status monitoring
5. Mock process spawning for testing
6. Tests for error handling during server operations
7. Integration tests with the ConfigurationEngine
8. Performance tests for server discovery

# Subtasks:
## 1. Create Core ServerManager Structure [done]
### Dependencies: None
### Description: Create the core ServerManager structure and server registry for managing MCP server lifecycle
### Details:
Implement the foundational ServerManager with:
- ServerRegistry for tracking available and installed servers
- ServerStatus enum for server states (Running, Stopped, Error, Unknown)
- Basic server management methods (start, stop, status)
- Integration with existing configuration engine
- Simple process tracking for running servers

## 2. Implement Server Discovery [done]
### Dependencies: None
### Description: Implement server discovery functionality to scan for available and installed MCP servers
### Details:
Implement server discovery in ServerManager:
- Add discover_servers() method to scan system for MCP servers
- Integrate with ApplicationDetector to find MCP-enabled applications
- Scan common locations for MCP server binaries and configurations
- Populate ServerRegistry with available and installed servers
- Update last_scan timestamp
- Add comprehensive error handling and logging

## 3. Implement Server Installation and Registration [done]
### Dependencies: None
### Description: Implement server installation and registration functionality for managing MCP server lifecycle
### Details:
Implement server installation in ServerManager:
- Add install_server() method to install MCP servers from available registry
- Add register_server() method to register custom servers
- Add remove_server() method to uninstall servers
- Update ServerRegistry to track installed vs available servers
- Integrate with ConfigurationEngine for persistent storage
- Add comprehensive error handling and validation

