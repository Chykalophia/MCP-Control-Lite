# Task ID: 9
# Title: Implement Backup and Restore Functionality
# Status: done
# Dependencies: 1, 2, 4
# Priority: medium
# Description: Create a system for backing up and restoring MCP server configurations to prevent data loss and enable configuration sharing.
# Details:
Implement a BackupService class to handle configuration backup and restore:

```typescript
class BackupService {
  private fileSystem: FileSystemService;
  private configEngine: ConfigurationEngine;
  private backupLocation: string;
  
  constructor(fileSystem: FileSystemService, configEngine: ConfigurationEngine, backupLocation?: string) {
    this.fileSystem = fileSystem;
    this.configEngine = configEngine;
    this.backupLocation = backupLocation || this.getDefaultBackupLocation();
  }
  
  // Get default backup location
  private getDefaultBackupLocation(): string {
    // Default to ~/Library/Application Support/MCP Control Lite/backups
    return path.join(os.homedir(), 'Library', 'Application Support', 'MCP Control Lite', 'backups');
  }
  
  // Create a backup of all configurations
  async createBackup(name?: string): Promise<string> {
    // Ensure backup directory exists
    await fs.mkdir(this.backupLocation, { recursive: true });
    
    // Generate backup filename
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupName = name || `backup-${timestamp}`;
    const backupPath = path.join(this.backupLocation, `${backupName}.json`);
    
    // Get all configurations
    const configurations = this.configEngine.getServerConfigurations();
    
    // Create backup object
    const backup = {
      version: '1.0.0',
      createdAt: new Date().toISOString(),
      configurations
    };
    
    // Write backup file
    await this.fileSystem.writeConfig(backupPath, backup);
    
    return backupPath;
  }
  
  // List available backups
  async listBackups(): Promise<{ name: string, path: string, createdAt: Date }[]> {
    // Ensure backup directory exists
    await fs.mkdir(this.backupLocation, { recursive: true });
    
    // Get all backup files
    const files = await fs.readdir(this.backupLocation);
    const backupFiles = files.filter(file => file.endsWith('.json'));
    
    // Get backup info
    const backups = [];
    for (const file of backupFiles) {
      try {
        const filePath = path.join(this.backupLocation, file);
        const stats = await fs.stat(filePath);
        const backup = await this.fileSystem.readConfig(filePath);
        
        backups.push({
          name: file.replace('.json', ''),
          path: filePath,
          createdAt: new Date(backup.createdAt || stats.mtime)
        });
      } catch (error) {
        console.error(`Failed to read backup ${file}:`, error);
      }
    }
    
    // Sort by creation date (newest first)
    return backups.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }
  
  // Restore from backup
  async restoreBackup(backupPath: string): Promise<void> {
    // Read backup file
    const backup = await this.fileSystem.readConfig(backupPath);
    
    // Validate backup format
    if (!backup.configurations || !Array.isArray(backup.configurations)) {
      throw new Error('Invalid backup format');
    }
    
    // Create backup of current state before restoring
    await this.createBackup('pre-restore-' + new Date().toISOString().replace(/[:.]/g, '-'));
    
    // Restore each configuration
    for (const config of backup.configurations) {
      await this.configEngine.updateServerConfiguration(config);
    }
  }
  
  // Export configurations to file
  async exportConfigurations(filePath: string): Promise<void> {
    const configurations = this.configEngine.getServerConfigurations();
    
    const exportData = {
      version: '1.0.0',
      exportedAt: new Date().toISOString(),
      configurations
    };
    
    await this.fileSystem.writeConfig(filePath, exportData);
  }
  
  // Import configurations from file
  async importConfigurations(filePath: string): Promise<void> {
    const importData = await this.fileSystem.readConfig(filePath);
    
    // Validate import format
    if (!importData.configurations || !Array.isArray(importData.configurations)) {
      throw new Error('Invalid import format');
    }
    
    // Create backup of current state before importing
    await this.createBackup('pre-import-' + new Date().toISOString().replace(/[:.]/g, '-'));
    
    // Import each configuration
    for (const config of importData.configurations) {
      await this.configEngine.updateServerConfiguration(config);
    }
  }
}
```

Implement a template system for common MCP server configurations:

```typescript
class TemplateSystem {
  private templates: Record<string, MCPServerConfig> = {};
  
  constructor() {
    // Load built-in templates
    this.loadBuiltInTemplates();
  }
  
  // Load built-in templates
  private loadBuiltInTemplates(): void {
    this.templates = {
      'filesystem': {
        id: 'template-filesystem',
        name: 'Filesystem MCP Server',
        type: 'built-in',
        enabled: true,
        parameters: {
          rootPath: '~/Documents',
          allowedExtensions: ['.txt', '.md', '.json']
        },
        metadata: {
          version: '1.0.0',
          lastModified: new Date(),
          createdAt: new Date()
        }
      },
      'git': {
        id: 'template-git',
        name: 'Git Repository MCP Server',
        type: 'built-in',
        enabled: true,
        parameters: {
          repoPath: '~/Projects',
          branch: 'main'
        },
        metadata: {
          version: '1.0.0',
          lastModified: new Date(),
          createdAt: new Date()
        }
      },
      // Add more templates as needed
    };
  }
  
  // Get all available templates
  getTemplates(): Record<string, MCPServerConfig> {
    return this.templates;
  }
  
  // Get a specific template
  getTemplate(id: string): MCPServerConfig | undefined {
    return this.templates[id];
  }
  
  // Create a new configuration from template
  createFromTemplate(templateId: string, name: string): MCPServerConfig {
    const template = this.getTemplate(templateId);
    if (!template) {
      throw new Error(`Template not found: ${templateId}`);
    }
    
    // Generate a unique ID
    const id = `${templateId}-${Date.now()}`;
    
    // Create new configuration from template
    return {
      ...template,
      id,
      name,
      metadata: {
        ...template.metadata,
        createdAt: new Date(),
        lastModified: new Date()
      }
    };
  }
}
```

Integrate these services with both the GUI and CLI interfaces to provide a consistent backup and restore experience.

# Test Strategy:
1. Unit tests for BackupService methods
2. Tests for backup file format and validation
3. Tests for restore functionality
4. Tests for template system
5. Tests for error handling during backup/restore
6. Integration tests with ConfigurationEngine
7. Tests for file system interactions
8. Tests for backup naming and organization
9. Tests for import/export functionality
10. End-to-end tests for backup and restore workflows

# Subtasks:
## 1. Add Pre-Sync Backup Protection [done]
### Dependencies: None
### Description: Create automatic backup functionality before any sync operations
### Details:
Implement automatic backup before sync operations:
- Create backup directory structure
- Add pre-sync backup creation
- Backup individual config files before modification
- Add CLI commands for manual backup/restore
- Include timestamp and metadata in backups

## 2. Complete Import/Export Functionality [done]
### Dependencies: None
### Description: Complete import functionality to store servers in central store
### Details:
Complete the import-from command to actually store discovered servers in the central configuration store:
- Parse MCP server configs from application files
- Convert to internal server format
- Store in central configuration store
- Add export-to functionality for pushing to other apps
- Enable safe bidirectional sync

## 3. Add Live Multi-Source Server Discovery [pending]
### Dependencies: None
### Description: Implement live multi-source MCP server discovery
### Details:
Add live search functionality from multiple sources:
- NPM Registry API for real packages
- GitHub Search API for repositories  
- Built-in curated catalog
- PulseMCP integration (pending API access)
- Install command integration for discovered servers

