# Task ID: 3
# Title: Build Application Detection System
# Status: done
# Dependencies: 1, 2
# Priority: high
# Description: Create a system to automatically detect installed MCP-enabled applications on the user's macOS system.
# Details:
Implement an ApplicationDetector class that scans the system for known MCP-enabled applications:

```typescript
class ApplicationDetector {
  // List of known MCP-enabled applications and their detection patterns
  private readonly knownApplications = [
    {
      name: 'Claude Desktop',
      bundleId: 'com.anthropic.claude',
      configPath: '~/Library/Application Support/Claude/claude_desktop_config.json',
      executablePaths: ['/Applications/Claude.app']
    },
    {
      name: 'Cursor',
      bundleId: 'com.cursor.Cursor',
      configPath: '~/Library/Application Support/Cursor/User/settings.json',
      executablePaths: ['/Applications/Cursor.app']
    },
    // Add more applications as needed
  ];

  // Scan for installed applications
  async detectApplications(): Promise<ApplicationProfile[]> {
    const detectedApps: ApplicationProfile[] = [];
    
    for (const app of this.knownApplications) {
      const isInstalled = await this.checkIfInstalled(app);
      if (isInstalled) {
        detectedApps.push({
          id: app.bundleId,
          name: app.name,
          configPath: this.expandPath(app.configPath),
          format: 'json', // Default, could be detected
          adapter: app.name.toLowerCase().replace(' ', '-'),
          detected: true,
          lastSync: null
        });
      }
    }
    
    return detectedApps;
  }

  // Check if an application is installed
  private async checkIfInstalled(app: any): Promise<boolean> {
    // Check if executable exists
    // Could also use macOS-specific APIs like NSWorkspace
    // or shell out to 'mdfind' for bundle ID lookup
  }

  // Expand ~ to home directory in paths
  private expandPath(path: string): string {
    // Replace ~ with actual home directory path
  }
}
```

Implement methods to detect applications using multiple strategies:
1. Check for application bundles in standard locations
2. Use macOS-specific APIs to query installed applications
3. Look for configuration files in known locations
4. Allow manual registration of applications

# Test Strategy:
1. Unit tests with mocked file system to verify detection logic
2. Tests for each supported application type
3. Tests with missing applications
4. Tests for path expansion and normalization
5. Integration tests on systems with known applications installed
6. Performance tests to ensure scanning is efficient
7. Tests for manual application registration

# Subtasks:
## 1. Define MCP-Enabled Application Profiles [done]
### Dependencies: None
### Description: Establish a comprehensive, extensible list of MCP-enabled applications, including their bundle IDs, configuration file paths, and executable locations for detection.
### Details:
Document detection patterns for Claude Desktop, Cursor, Zed, VS Code, and other MCP clients. Ensure the structure supports future additions and updates.

## 2. Implement Multi-Strategy Application Detection [done]
### Dependencies: 3.1
### Description: Develop detection logic that checks for application bundles in standard locations, queries macOS APIs for installed applications, and verifies configuration files in known paths.
### Details:
Use bundle ID lookups, executable existence checks, and configuration file presence to confirm installation status. Integrate with PathResolver for path normalization.

## 3. Support Manual Application Registration [done]
### Dependencies: 3.1, 3.2
### Description: Allow users to manually register MCP-enabled applications not automatically detected, specifying custom detection patterns and configuration locations.
### Details:
Provide an interface for manual entry and validation of application details, ensuring seamless integration with automatic detection results.

## 4. Verify and Extract Application Configuration Profiles [done]
### Dependencies: 3.2, 3.3
### Description: For each detected application, validate the existence and format of its configuration file, and extract relevant MCP server configuration details.
### Details:
Leverage the file system service from Task 2 to read and validate configuration files, ensuring correct format (e.g., JSON) and extracting necessary metadata.

## 5. Generate Detailed Application Detection Reports [done]
### Dependencies: 3.4
### Description: Produce structured profiles for each detected application, including installation status, configuration validation results, and extracted metadata for downstream use.
### Details:
Format detection results into standardized profiles for use by adapters and the GUI. Include fields such as bundle ID, name, config path, format, adapter, detected status, and last sync.

